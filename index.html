<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Redirecting...</title>

  <!-- Dot Matrix Font -->
  <link href="https://fonts.cdnfonts.com/css/square-dot-matrix" rel="stylesheet">

  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #f5f5f5;
      font-family: 'Square Dot Matrix', monospace;
      color: #333;
    }
    #large-header {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 1;
    }
    #network-canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
    .center {
      position: relative;
      z-index: 2;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    h1 {
      font-size: 2.8rem;
      color: #ffbd59;
      margin: 0;
      border-right: 2px solid #333;
      white-space: nowrap;
      overflow: hidden;
      width: 0;
      animation: typing 2.5s steps(12, end) forwards, blink 0.7s infinite;
    }
    .countdown {
      font-size: 1.4rem;
      margin-top: 15px;
      color: #555;
      opacity: 0;
      animation: fadeIn 1.5s ease-in-out forwards;
      animation-delay: 2.6s;
    }
    .bottom-left {
      position: fixed;
      bottom: 15px;
      left: 20px;
      font-size: 0.95rem;
      color: #333;
      opacity: 0.85;
      z-index: 2;
    }
    .bottom-left a {
      color: #ffbd59;
      text-decoration: none;
      font-weight: bold;
    }
    .bottom-left a:hover {
      text-decoration: underline;
    }
    @keyframes typing { from { width: 0; } to { width: 14ch; } }
    @keyframes blink { 50% { border-color: transparent; } }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>

  <div id="large-header">
    <canvas id="network-canvas"></canvas>
    <div class="center">
      <h1>Redirecting...</h1>
      <div class="countdown">Redirecting in <span id="timer">5</span>s</div>
    </div>
  </div>

  <div class="bottom-left">
    We’re redirecting you to our new site…  
    <a href="https://beebotix.com/">Click here</a>
  </div>

  <script>
    // Redirect countdown
    let timeLeft = 5;
    const timerEl = document.getElementById("timer");
    const countdown = setInterval(() => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      if (timeLeft <= 0) {
        clearInterval(countdown);
        window.location.href = "https://beebotix.com/";
      }
    }, 1000);

    // Canvas network animation (inspired by Marco’s Pen)
    (function() {
      const canvas = document.getElementById('network-canvas');
      const ctx = canvas.getContext('2d');
      let width = canvas.width = window.innerWidth;
      let height = canvas.height = window.innerHeight;
      const target = { x: width / 2, y: height / 2 };
      let points = [];

      // Create grid of points
      const createPoints = () => {
        points = [];
        const spacingX = width / 20;
        const spacingY = height / 20;
        for (let x = 0; x < width; x += spacingX) {
          for (let y = 0; y < height; y += spacingY) {
            const px = x + Math.random() * spacingX;
            const py = y + Math.random() * spacingY;
            points.push({ x: px, y: py, originX: px, originY: py, active: 0, circleActive: 0, closest: [] });
          }
        }
        // Compute closest neighbors
        points.forEach(p1 => {
          const sorted = points.filter(p2 => p2 !== p1)
            .sort((a, b) => ((p1.x - a.x) ** 2 + (p1.y - a.y) ** 2) - ((p1.x - b.x) ** 2 + (p1.y - b.y) ** 2))
            .slice(0, 5);
          p1.closest = sorted;
        });
      };

      function drawLines(p) {
        if (!p.active) return;
        p.closest.forEach(c => {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(c.x, c.y);
          ctx.strokeStyle = `rgba(100,150,200,${p.active})`;
          ctx.stroke();
        });
      }

      function drawCircle(p) {
        if (!p.circleActive) return;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI, false);
        ctx.fillStyle = `rgba(100,150,200,${p.circleActive})`;
        ctx.fill();
      }

      function animate() {
        ctx.clearRect(0, 0, width, height);
        points.forEach(p => {
          // Distance from cursor (or center)
          const dx = target.x - p.x;
          const dy = target.y - p.y;
          const dist = dx * dx + dy * dy;
          if (dist < 40000) {
            p.active = 0.3;
            p.circleActive = 0.6;
          } else if (dist < 160000) {
            p.active = 0.1;
            p.circleActive = 0.3;
          } else {
            p.active = 0;
            p.circleActive = 0;
          }
          drawLines(p);
          drawCircle(p);
        });
        requestAnimationFrame(animate);
      }

      window.addEventListener('mousemove', e => {
        target.x = e.clientX;
        target.y = e.clientY;
      });

      window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        createPoints();
      });

      createPoints();
      animate();
    })();
  </script>
</body>
</html>
